
- [各种网络IO的模型对比](#各种网络io的模型对比)
    - [各种概念的解读](#各种概念的解读)
    - [Linux 的网络IO模型](#linux-的网络io模型)
        - [五种模型](#五种模型)
    - [Java 的IO模型](#java-的io模型)
        - [BIO](#bio)
        - [NIO  非阻塞IO](#nio--非阻塞io)
        - [AIO](#aio)


# 各种网络IO的模型对比

## 各种概念的解读

- 同步 和 异步

    同步: 同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)

    所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是一旦调用返回，就得到返回值了。
    
    换句话说，就是由**调用者**主动等待这个**调用**的结果。

    异步则是相反，**调用**在发出之后，这个调用就直接返回了，所以没有返回结果。

    换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在**调用**发出后，**被调用者**通过状态、通知来通知调用者，或通过回调函数处理这个调用。

- 阻塞 非阻塞

    阻塞和非阻塞关注的是程序在**等待调用结果（消息，返回值）时的状态**.

    阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

    非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

## Linux 的网络IO模型

### 五种模型

- 阻塞IO

- 非阻塞IO

- I/O复用模型

- 信号驱动IO模型

- 异步IO模型



## Java 的IO模型


AIO BIO NIO 概念

BIO(Blocking IO)指的是同步阻塞IO操作。
NIO(Non-Blocking IO)指的是同步非阻塞IO操作。
AIO(Asynchronous I/O)指的是异步非阻塞IO操作。

### BIO 

    请求发出后,等到处理结果在返回,一个请求对应一个线程

### NIO  非阻塞IO

    NIO不是每个线程都会启动新的线程,有一下几种概念

- 缓存Buffer

    不直接读取，而是所有的操作倒是要通过缓存

    在NIO中，所有数据都是用缓冲区处理，在读取数据的时候，它是直接读到缓冲区中，在写如数据的时候，也是写 到缓冲区。任何时候访问NIO中的数据，都是通过缓冲区进行的操作 

- 通道Channel 

    与流的区别: 流是单向的, channel 是全双工的 双向的

    Channel 通道，就像一个自来水管一样，可以通过它读取 和写入数据，Channel是全双工的，所以数据是双向流动

- 多路复用器 Selector

    轮询机制

    多路复用器Selector，是NIO的基础，多路复用器提供选 择已经就绪的任务的能力，简单来说，Selector 会不断轮 询注册上的Channel，如果某个Channel上面有新的TCP 连接接入、读、写事件，这个 Channel 就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪的Channel进行I/O操作；一个多路复用器可以同时轮询多个 Channel。通过这个机制可以接入成千上万的客户端。

    I/O多路复用，I/O就是指的我们网络I/O,多路指多个TCP连接(或多个Channel)，复用指复用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量的线程来处理这些连接。

### AIO 

    特殊的IO,异步IO,请求发出后，当应用程序访问内核请求数据后，会直接返回，此时操作系统会完成第一第二阶段，当数据准备完毕后再通知应用程序，此过程应用程序可做任意事情，在这一阶段，和NIO不同的是NIO会主动轮询操作系统数据是否准备完毕，而AIO则是等待系统主动通知，再去取数据。
   
- 如何通过非阻塞提高性能

    非阻塞要解决的就是I/O线程与Socket解耦的问题，因此，它引入了事件机制来达到解耦的目的。我们可以认为 NIO底层中存在一个I/O调度线程，它不断的扫描每个 Socket的缓冲区，当发现写入缓冲区为空的时候，它会 产生一个Socket可写事件，此时程序就可以把数据写入 到Socket中。如果一次写不完，就等待下一次的可写事 件通知；反之，当发现缓冲区里有数据的时候，它会产生 一个Socket可读事件，程序收到这个通知事件就可以从 Socket读取数据了。 